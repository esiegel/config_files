############## OH_MY_ZSH INIT

ZSH=$HOME/.oh-my-zsh
ZSH_THEME="robbyrussell"

DISABLE_AUTO_UPDATE="true"

# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
plugins=(git git-extras git-flow osx pip virtualenvwrapper zsh-syntax-highlighting)

# oh-my-zsh entry
source $ZSH/oh-my-zsh.sh

############## ZSH CONFIG

export PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin

# Direnv hook for loading directory environments
# Setting an empty log format prevents logging.
eval "$(direnv hook zsh)"
export DIRENV_LOG_FORMAT=""

# Increase cmd history size
export HISTSIZE=5000

# don't ask if "this is correct"
unsetopt correct_all
unsetopt correct

# set editor variables
export EDITOR=$(which vim)
export PAGER=less

# Less needs to pass through escaped color characters.
export LESS=-R

CODE=$HOME/code

if [[ -d $HOME/Dropbox ]]; then
   DROPBOX=$HOME/Dropbox
elif [[ -d "$HOME/Dropbox (Personal)" ]]; then
   DROPBOX="$HOME/Dropbox (Personal)"
fi

# load custom source
if [[ -f $HOME/.zshrc-custom ]]; then
   source $HOME/.zshrc-custom
fi

# load all files in .zsh_files
for file in ~/.zsh_files/*(DN); do
  source "$file"
done

# allow CTRL-x-e to edit the command line in $EDITOR
autoload edit-command-line
zle -N edit-command-line
bindkey '^Xe' edit-command-line

############## NODE

# Add Node modules to path
export PATH=$PATH:/usr/local/share/npm/bin

############## Haskell

# add haskell cabal binaries to path
export PATH=$PATH:$HOME/.cabal/bin

# cabal uninstall
cabal-uninstall() {
   if [[ $# -ne 1 ]]; then
       echo cabal-uninstall: need to speicify package to uninstall
       return 1
   fi
   package=$1
   ghc-pkg unregister $package >/dev/null 2>&1
   find ~/.cabal -type d -name "*$package*" | xargs rm -rf
   find ~/.cabal -type f -name "*$package*" | xargs rm
}

################## GOLANG

export GOPATH=$CODE/go
export PATH=$PATH:$GOPATH/bin

################## Node

export PATH=$PATH:$CODE/tern/bin

################## Other

# Sourcetree to path
alias stree=/Applications/SourceTree.app/Contents/Resources/stree

alias emacsapp="open /usr/local/Cellar/emacs/24.4-dev/Emacs.app"

# ack 2.0 doesn't support searching all files, this does.
alias acka="ack --type-set='all:match:.*' -k"

# Virtualbox vm control
alias start_kernvm="VBoxManage startvm --type headless kernel_dev"
alias stop_kernvm="VBoxManage controlvm kernel_dev poweroff"
alias ssh_kernvm="ssh -p 2222 eric@127.0.0.1"

# shortcuts
# note: dropbox can contain spaces so we must wrap it in quotes
alias ideas="$EDITOR \"$DROPBOX/ideas.md\""
alias notes="$EDITOR \"$DROPBOX/notes.md\""
alias questions="$EDITOR \"$DROPBOX/questions.md\""
alias scratch="$EDITOR \"$DROPBOX/scratch.md\""
alias todo="$EDITOR \"$DROPBOX/todo.md\""

# android sdk
export ANDROID_HOME=/usr/local/opt/android-sdk

# GPG default key
export GPGKEY=ED6BE39D

# swift repl
alias swift="xcrun --sdk iphonesimulator8.0 swift"

# add local scripts
export PATH=$PATH:$CODE/scripts

# fasd init
eval "$(fasd --init auto)"
alias v='f -e vim' # quick opening files with vim
alias o='a -e open' # quick opening files with open

# ruby env home
export RBENV_ROOT=/usr/local/var/rbenv
alias bundleinstall="bundle install --path .gems"

# To enable shims and autocompletion add to your profile:
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

# arcanist code review
export PATH=$PATH:$CODE/arcanist/bin
source $CODE/arcanist/resources/shell/bash-completion

# include scripts
export PATH=$PATH:$CODE/scripts

exit_if_failure() {
  exit_code=$?
  msg=${1:-BAD_EXIT_CODE}

  if [[ $exit_code != 0 ]]; then
    echo $msg
    exit $exit_code
  fi
}

############## GIT HELPERS

# modified files
alias modified_files="git ls-files -m -o -X .gitignore -X ~/.gitignore"

# find recent files committed
recent_changes() {
  local start_revision=${1:-HEAD^}
  local end_revision=${2:-HEAD}
  git diff-tree --name-only -r "${start_revision}..${end_revision}"
  git ls-files --others --exclude-standard
}


backup_branch() {
  #CODE_BACKUP_DIR must be defined

  local start_revision=${1:-HEAD^}
  local end_revision=${2:-HEAD}
  local repo_name=$(basename $(git rev-parse --show-toplevel))
  local branch_name=$(git rev-parse --abbrev-ref HEAD)
  local now=$(date +'%Y%m%d_%H%M%s')
  local backup_dir="${CODE_BACKUP_DIR}/${repo_name}/${branch_name}/${branch_name}_${now}"
  local files_path=${backup_dir}/_files.txt

  mkdir -p $backup_dir
  recent_changes $start_revision $end_revision > $files_path
  modified_files >> $files_path
  sort -u -o $files_path $files_path
  rsync -a --files-from=$files_path . $backup_dir
}

num_lines_changed() {
  local start_revision=${1:-HEAD^}
  local end_revision=${2:-HEAD}
  git diff --stat $start_revision $end_revision | grep '|' | egrep -v "Bin \d+ -> \d+ bytes" | tr -s ' ' | cut -d'|' -f 2 | cut -d ' ' -f 2 | paste -sd+ - | bc
}

############## AWS HELPERS

ec2_instances() {
  # Fetches EC2 instance info.
  #
  # {
  #   "i-9e1dfa63": {
  #     "dns": "ec2-54-175-236-111.compute-1.amazonaws.com",
  #     "name": "logstash-02"
  #   },
  #   "i-9f1dfa62": {
  #     "dns": "ec2-54-175-242-4.compute-1.amazonaws.com",
  #     "name": "logstash-02"
  #   }
  # }

  local cmd='aws ec2 describe-instances --filters "Name=instance-state-name,Values=running"'
  local jqcmd="jq --sort-keys '.Reservations | map(.Instances) | flatten | map({key: .InstanceId, value: {name: .Tags[0].Value, dns: .PublicDnsName}}) | from_entries'"
  if [[ -n $1 ]]; then
    cmd="$cmd --filters 'Name=tag:Name,Values=*$1*'"
  fi

  eval $cmd | eval $jqcmd
}
